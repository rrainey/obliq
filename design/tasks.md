# Implementation Plan for Visual Modeling & Simulation Web App MVP

## Setup & Environment

* **Initialize Next.js Project:** *Start* with an empty development environment (Node.js installed). Create a new Next.js app (TypeScript enabled) using the official CLI. *End* with the default Next.js starter running locally (verify by opening `localhost:3000` and seeing the Next.js welcome page).

* **Add Supabase Dependencies:** *Start* by installing Supabase’s JS client and any needed helpers in the Next.js project (e.g. `@supabase/supabase-js`). Configure a `.env.local` with Supabase project URL and anon key. *End* when the Supabase client can be initialized with the URL and key without errors.

* **Configure Supabase Client:** *Start* by creating a utility module (e.g. `supabaseClient.js`) that initializes the Supabase client with the env credentials. *End* with a exported Supabase client object that can be imported anywhere to call Supabase APIs (test by successfully fetching `supabase.auth.getSession()` or similar with no runtime errors).

## User Authentication

* **Implement Sign-Up Functionality:** *Start* by creating a registration page or form (email & password inputs). Use Supabase client’s `auth.signUp()` method to register new users. *End* when a user can sign up and is automatically logged in (verified by Supabase returning a user session or by checking the Supabase Auth dashboard for the new user).

* **Implement Login Functionality:** *Start* by creating a login form (email & password). Use Supabase `auth.signInWithPassword()` to authenticate. *End* when an existing user can log in and the app obtains a valid session (e.g., test by logging in with the user created in the previous step and verifying a session token is present).

* **Manage Auth State:** *Start* by setting up a listener or context to track authentication state (using Supabase’s onAuthStateChange or checking session on page load). *End* when the app reliably knows if a user is logged in or not (e.g., displays the user’s email or UID when logged in, and nothing when logged out), allowing conditional UI rendering.

* **Protect Editor Route:** *Start* by implementing route guarding for the modeling page (e.g., Next.js middleware or client-side check). If no valid Supabase session, redirect to login. *End* when navigating to the editor page without a login sends the user to the login page, and only authenticated users can access the editor.

* **Implement Logout:** *Start* by adding a logout button that calls `supabase.auth.signOut()` and clears any stored session data. *End* when clicking “Logout” ends the Supabase session and returns the app to an unauthenticated state (e.g., user is redirected to login and must re-login to access protected pages).

## Editor Canvas & Blocks UI

* **Create Editor Page Skeleton:** *Start* by adding a new protected page (e.g. `/editor`) in Next.js. Include a basic layout with a toolbar (for Save, Run, etc.) and a main canvas area. *End* when the editor page loads (after login) showing the empty canvas region and basic UI elements, confirming the routing and protection work.

* **Integrate Drag-and-Drop Library:** *Start* by installing a node-diagram library (for example, **React Flow**) to simplify building the canvas. Because implementing drag-and-drop from scratch is complex and error-prone, use this library’s built-in support for draggable nodes and connecting edges. *End* when the editor page renders a React Flow canvas component covering the main area (verify no console errors and that you can pan/zoom the blank canvas, which React Flow provides by default).

* **Implement Block Palette UI:** *Start* by creating a sidebar or toolbar listing all available block types (Sum, Multiply, Transfer Function, Input Port, Output Port, Display, Logger, Subsystem). Each list item should be draggable or clickable. *End* when the palette is visible with each block type listed (with an icon or label) and ready for drag-and-drop (e.g., test that the DOM elements have draggable attributes or onClick handlers in place).

* **Enable Block Creation via Drag-Drop:** *Start* by adding logic so that dragging a palette item onto the canvas creates a new node. Use the HTML5 Drag and Drop API or React Flow’s example for external drops to detect a drop position and add a node to the React Flow graph. *End* when a user can drag a block type from the palette and upon drop, a new node of that type appears on the canvas at the drop location (verify by dropping a “Sum” block and seeing a node with a “Sum” label on the canvas).

* **Define Block Data Model:** *Start* by setting up a structure for node data (type, unique ID, position, parameters, etc.) and edge data (source node, target node, source port, target port). This can be managed via React Flow’s state or a custom state. *End* when the application maintains an internal JSON representation of the model (nodes and connections) that updates whenever blocks are added or connected (test by logging the structure whenever a change happens).

* **Implement Sum Block Node:** *Start* by creating a custom React Flow node component for the **Sum** block. It should display a “+” or “Sum” label and have two **input** handles and one **output** handle (for two inputs summed to one output). Use React Flow’s `<Handle>` elements to define these connectors. *End* when adding a Sum node to the canvas shows a block with the correct label and it has visible connector dots for two inputs on the left and one output on the right (verify visually that handles appear and can be connected).

* **Implement Multiply Block Node:** *Start* by creating a node component for **Multiply** similar to Sum. Display a “×” or “Mul” label, with two input handles and one output handle. *End* when a Multiply node can be added and shows with the proper label and port handles.

* **Implement Input Port Block Node:** *Start* by creating a node for **Input Port**. This represents an external input (or a constant source) in the model. Give it no input handles (since it’s a source) and one output handle. Provide a way to specify a constant value (e.g., a small text field in the node for a number). *End* when an Input Port node appears with a label (like “Input”) and one output connector; if a default constant is set (say 0), it’s displayed for clarity.

* **Implement Output Port Block Node:** *Start* by creating a node for **Output Port**. This represents a model’s output terminal. Give it one input handle and no outputs. *End* when an Output Port node appears with a label (e.g., “Output”) and a single input connector on the left. (Visually, it might look similar to Input Port but with the handle on the opposite side.)

* **Implement Display Block Node:** *Start* by creating a node for **Display**. This block will show the value of a signal during simulation. It should have one input handle and no outputs. In the UI, include a read-only text field or box that will later display the input value. *End* when a Display node can be added, showing a placeholder (like “---” or 0) for its value and an input connector to receive a signal.

* **Implement Logger Block Node:** *Start* by creating a node for **Logger**. The Logger will record a signal’s values but not output anything. It has one input handle and no outputs. *End* when a Logger node appears with a label (“Logger”) and an input connector. (This block might not have much UI beyond the label, as logging will be internal.)

* **Implement Transfer Function Block Node:** *Start* by creating a node for **Transfer Function**. It should have one input handle and one output handle. Include UI elements for its parameters: for example, two text fields for numerator and denominator coefficients (allowing a comma-separated list of numbers for each). *End* when a Transfer Function node appears with one input and one output connector and allows entry of coefficients (e.g., default to “1 / (1s+1)” or ask the user to input `[num]` and `[den]`). (Test by adding a TF block and entering simple coefficients like “1” for numerator and “1,1” for denominator.)

* **Implement Subsystem Block Node:** *Start* by creating a node type for **Subsystem**. Represent it as a block that can contain an internal model. Initially, give it a default of one input handle and one output handle (these will update based on its contents). Label it “Subsystem”. *End* when a Subsystem node can be added to the canvas, showing a generic Subsystem label with at least one input and output connector visible (even if not functional yet).

* **Enable Node Drag & Move:** *Start* by ensuring that once nodes are on the canvas (via React Flow), they can be repositioned by dragging. (React Flow provides this out-of-the-box for node components.) *End* when you can click and drag any placed block to a new position on the canvas and the node moves (verify that its connectors remain attached to any connected edges during movement, which is automatic with the library).

* **Connect Blocks with Wires:** *Start* by implementing connection handling between node ports. Using the diagram library’s connector mechanism, allow users to drag from an output handle to another block’s input handle. Implement an `onConnect` callback to update the model’s edge list when a connection is made. *End* when the user can draw a connection line from one block’s output to another’s input and an edge object is created in state (verify that a line appears on the canvas connecting the two blocks after dropping the connection).

* **Auto-Update Connections on Move:** *Start* by leveraging the library’s capability to keep edges linked to moving nodes. (React Flow will automatically adjust edge paths as nodes move.) *End* when moving a block that is already connected to others causes the connecting lines to update in real-time, maintaining the connections with no manual intervention (test by connecting blocks then dragging one around; the wire should stay attached).

## Subsystem Functionality

* **Data Structure for Subsystems:** *Start* by extending the model data structure to support nested sub-models. For example, allow the Subsystem node’s data to include its own list of internal nodes and connections. *End* when the code can hold a hierarchy (e.g., a global model containing a Subsystem node which contains its own model data). Test by manually inserting a dummy internal structure into a Subsystem node’s data and ensuring it doesn’t break serialization.

* **Open Subsystem Editor:** *Start* by implementing a UI action (e.g., double-click or a context menu option on a Subsystem node) to “enter” the subsystem. This should swap the canvas view to edit the Subsystem’s internal model. One approach is to maintain a stack of editing contexts; push the Subsystem’s context and render its nodes in React Flow. *End* when double-clicking a Subsystem node clears the main canvas and shows an empty canvas for the Subsystem’s contents (verify that you can tell you are now editing inside the Subsystem, perhaps by a breadcrumb or changed title).

* **Add In-Port/Out-Port Nodes in Subsystem:** *Start* by introducing special **InPort** and **OutPort** block types that can only be used inside a Subsystem canvas. An InPort node represents a connection from the Subsystem’s external inputs, and should have one **output** handle (no inputs) inside the subsystem. An OutPort node represents output going out of the Subsystem, and should have one **input** handle (no outputs) inside. *End* when the Subsystem internal editor allows adding InPort and OutPort nodes (with appropriate labeling, e.g., “In1”, “Out1”), and they appear with the correct connectors inside the Subsystem.

* **Dynamic Subsystem Port Mapping:** *Start* by implementing logic to sync the Subsystem node’s external ports with its internal port blocks. For example, whenever InPort or OutPort nodes are added or removed inside, update the parent Subsystem node to have matching number of external handles. *End* when adding an InPort inside a Subsystem causes the Subsystem block (on the parent canvas) to show a new input handle (and similarly for OutPort -> new output handle). Test by adding multiple InPort/OutPort blocks inside and confirming the Subsystem node reflects the correct count of connectors externally.

* **Exit Subsystem Editor:** *Start* by providing a way to exit the Subsystem (e.g., a “Back to Parent” button or breadcrumb). This should pop the editing context stack and re-render the parent model’s canvas. Make sure to preserve any changes made inside the Subsystem. *End* when clicking the back button returns to the top-level model view and the Subsystem node now shows updated ports (if any changes were made internally). Verify that internal connections persist by re-entering the Subsystem and seeing previously placed blocks and wires intact.

* **Connect Subsystem in Parent Model:** *Start* by allowing connections between the Subsystem node’s external handles and other blocks on the parent canvas. The Subsystem’s input handles should behave like any block’s input, and its output handles as any output. *End* when you can connect another block’s output into a Subsystem’s input, and also connect the Subsystem’s output to another block’s input on the main canvas. (This edge will effectively route into or out of the Subsystem’s internals during simulation.)

## Simulation Engine (Client-Side)

* **Define Simulation Data Structures:** *Start* by creating structures to hold runtime simulation state: e.g., a mapping of block IDs to current output values, and for stateful blocks (like Transfer Functions) to internal state (such as previous outputs/inputs for difference equations). *End* when there is a clear in-memory representation of the model’s computational state that can be initialized and updated each simulation step.

* **Topologically Sort Blocks:** *Start* by implementing a function to order blocks in a sequence such that each block comes after all of its prerequisites (input sources). This typically involves performing a topological sort on the directed graph of connections. *End* when given a model (without algebraic loops), the function returns an ordered list of block IDs where each block appears only after all blocks feeding into it. Test on a simple graph (e.g., Input -> Sum -> Output) to ensure the input comes before the sum, which comes before the output in the order.

* **Implement Sum Block Logic:** *Start* by coding the simulation behavior for the Sum block. It should take the numerical values of all incoming signals and output their sum. *End* when a Sum block can compute an output = sum(inputs). Test by feeding sample values: e.g., if two inputs carry 3 and 5, the Sum’s output should be 8 (verify by calling the logic function directly with these numbers).

* **Implement Multiply Block Logic:** *Start* by coding the simulation logic for the Multiply block. It multiplies its input values together. *End* when the Multiply block outputs the product of its inputs. Test with sample inputs: e.g., 2 and 4 should yield 8.

* **Implement Input Port Logic:** *Start* by determining how Input Port blocks provide values. For simulation, treat them as constant sources (using the user-defined value in the block). *End* when an Input Port outputs its stored constant each simulation step. Test by setting an Input Port’s value to 7 and verifying that the simulation engine reads 7 as its output at each step.

* **Implement Output Port Logic:** *Start* by implementing the Output Port behavior. In simulation this might simply pass its input value through (or mark it as a final output). *End* when connecting a signal to an Output Port causes that signal value to be recorded as a model output (e.g., stored in a results structure or printed for the user at end of simulation).

* **Implement Display Block Logic:** *Start* by coding the Display block to capture and show its input. In the simulation loop, when a Display block updates, store its input value in a way that can be reflected on the UI (e.g., update a value in the Display node’s state). *End* when, during simulation, the Display node’s shown value updates to the latest input signal. (Test by feeding a known sequence to a Display and verifying it shows the correct last value or real-time values if stepping through simulation).

* **Implement Logger Block Logic:** *Start* by coding the Logger block to record its input values over time. This could be an array or list attached to the block’s state. *End* when the Logger block, during simulation, appends each new input value (each step or each time it changes) to an internal list. Test by running a few simulation steps and checking that the logger’s list contains the sequence of input values it saw.

* **Implement Transfer Function Logic:** *Start* by implementing the **Transfer Function** block’s discrete simulation behavior. Use the numerator and denominator coefficients (e.g., for a difference equation). For each simulation step, compute the output based on the current input and stored state (previous inputs/outputs), updating the state for next step. *End* when the Transfer Function produces correct outputs for a simple test case (e.g., if configured as a pass-through `G(z)=1`, it should output the same as input; if configured as an integrator, its output accumulates the input over steps). Verify by simulating a known input sequence and comparing results to expected values (for example, a step input into an integrator should produce a ramp output).

* **Simulation Step Execution:** *Start* by writing a function to execute one simulation timestep across the whole model. This should: for each block in topological order, read its input signals (from either Input blocks or other blocks’ outputs computed earlier in the step) and compute its new output using the block’s logic. Handle stateful blocks by using their last stored state as needed. *End* when calling this function updates all block outputs for one time-step correctly. Test on a small static model: e.g., Input(5) -> Output; after one step, the Output port’s value should be 5.

* **Support Subsystem Simulation:** *Start* by extending the simulation engine to handle Subsystem blocks. When encountering a Subsystem block during simulation, invoke a simulation of its internal model. Feed the Subsystem’s internal Input Port values from the Subsystem block’s inputs, run the internal model’s step (which will compute its OutPort), then use that result as the Subsystem block’s output. Ensure this is done recursively if subsystems are nested. *End* when the simulation correctly propagates signals through a Subsystem: test by creating a simple subsystem (e.g., that just passes input to output internally) and verifying that a signal entering the Subsystem comes out unchanged at the parent level in simulation.

* **Simulation Control – Run/Pause:** *Start* by adding UI controls to run the simulation continuously. Implement a loop or interval that calls the step function repeatedly (with a fixed time step). Also add a pause/stop control to halt the loop. *End* when a user can click “Run” and see the simulation advancing (e.g., values changing on Display blocks or accumulating in Logger), and can click “Pause” to stop. Test by running a model with a known behavior (e.g., a Transfer Function receiving a step input) and observing the output change over several steps.

* **Reset Simulation State:** *Start* by ensuring there is a way to reset the simulation to initial state (e.g., all block outputs cleared, time = 0, transfer function states zeroed). This might be done whenever Run is pressed or via a dedicated “Reset” button. *End* when restarting a simulation yields the same results each time (given same inputs), indicating state was properly reset (test by running a scenario twice and confirming outputs match).

## Persistence (Saving & Loading Models)

* **Set Up Supabase Models Table:** *Start* by creating a new table in Supabase (via the dashboard or SQL). Define a `models` table with columns: `id` (UUID or serial), `user_id` (references auth users), `name` (text), and `data` (JSON) for the model structure. Enable Row Level Security and add a policy so that each user can *only* access their own models. *End* when the table is ready and a test insert via the Supabase dashboard confirms that data can be stored and retrieved (and that another user cannot access it due to RLS).

* **Implement Save Model Feature:** *Start* by coding a function that takes the current model (nodes and edges JSON) and saves it to Supabase. Use `supabase.from('models').insert(...)` with the model JSON and user ID (or an upsert if updating an existing model by name). Trigger this via a “Save” button in the UI, prompting for a model name if needed. *End* when clicking “Save” uploads the model to the database (verify by checking the returned data or looking at the Supabase table for a new entry). Test by saving a simple model and confirming it appears in the DB with correct JSON structure.

* **Implement Load Model Feature:** *Start* by coding a function to retrieve saved models for the logged-in user. On the UI, provide a list or dropdown of the user’s saved model names. When one is selected, fetch the model JSON from Supabase (`select()` where user\_id matches and maybe name). Parse the JSON and reinitialize the canvas state (nodes and edges) with it. *End* when selecting a saved model repopulates the editor with the exact blocks, connections, and positions from that save. Test by loading the model saved in the previous step and ensuring the canvas matches what was saved (positions of blocks, etc., and that simulation can run on it as before).

* **Model Editing State Management:** *Start* by ensuring that after loading a model, all internal references (IDs, subsystem data, etc.) are correctly set in the editor’s state. Also handle cases like unsaved changes (optional: warn user before loading another model). *End* when the app can seamlessly switch between different loaded models and continue editing or simulation without requiring a page refresh. (Test by loading one model, making a small change, saving as new, then loading the original to see it revert, etc., to confirm isolation of models in state.)

## C Code Generation (PlatformIO-Compatible)

* **Set Up Codegen API Endpoint:** *Start* by creating a Next.js API route (e.g., `/api/generate-code`) to handle code generation requests. This should accept a model identifier or JSON payload (for simplicity, send the JSON of the model in the request body). *End* when a basic API route is reachable (test with a GET or POST returning a dummy response) and wired up in the Next.js app (verify no route errors).

* **Define Code Generation Framework:** *Start* by outlining a function on the server that maps the model’s nodes and edges to C code representations. Decide on a code structure (e.g., one C file with a `step()` function, plus headers). *End* when there is a clear plan in code comments or pseudocode for generating files (e.g., create `model.c`, `model.h`, and perhaps a `main.c` for testing) and a mapping from each block type to C code snippet.

* **Generate Code for Sum Block:** *Start* by implementing code output for Sum blocks. For example, if a Sum block has two inputs `A` and `B`, generate C code like `double SumX_out = A + B;` (using unique names or indices for each block) to compute its output. *End* when the code generator produces the correct C line(s) for any Sum block in the model. Test by running codegen on a model with a Sum and verifying the output string includes the sum operation.

* **Generate Code for Multiply Block:** *Start* by adding code generation for Multiply blocks. Similar to Sum, output a line like `double MulY_out = A * B;`. *End* when a Multiply block in the model yields a correct multiplication line in the generated code.

* **Generate Code for Input Port:** *Start* by generating code for Input Port blocks. These could be represented as external inputs or constants. For MVP, treat them as constant values or variables. For example, output a definition like `double Input1_out = <initialValue>;` at the top of the step function (or as a global). *End* when each Input Port block produces code that defines its output value (using the user-provided constant). Verify by codegen on a model with an Input block and checking the constant appears in code.

* **Generate Code for Output Port:** *Start* by handling Output Port in codegen. An Output Port might simply pass through a signal to a final result. You can generate a line to assign its input to a named output variable (e.g., `output1 = SomeSignal;`). *End* when models with Output blocks produce a clear output assignment in code (or at least when the final outputs are identifiable in the generated code).

* **Generate Code for Transfer Function:** *Start* by implementing codegen for Transfer Function blocks. This is more involved: generate state variables (e.g., static arrays for previous inputs/outputs) and code that updates these each step using the difference equation. For example, produce code that uses the block’s numerator/denominator coefficients to compute the output (`TFZ_out`) and update state arrays. *End* when a Transfer Function block yields appropriate C code: declarations for its state and a sequence of computations (e.g., shift old values, calculate new output) inside the step function. (Test by generating code for a simple TF and reviewing the logic manually or even compiling it into a simple program for correctness.)

* **Handle Display/Logger in Codegen:** *Start* by deciding how to represent Display and Logger in generated code. Since they primarily serve debugging roles, you might simply omit them or turn them into debug printouts. For MVP, it’s acceptable to generate no code (or a comment) for these blocks. *End* when codegen runs on a model containing Display/Logger and produces a valid C program (those blocks might be ignored or commented, but do not break the code). For example, a Display block could result in a comment `// display value of X` or a `printf` if desired.

* **Assemble Complete Code Files:** *Start* by concatenating all generated code pieces into complete files. Create a `model.h` (with declarations, e.g., function prototypes, global state structs if any) and `model.c` (with the `model_step()` function implementing the block computations in order). Optionally, generate a `main.c` that calls `model_step()` in a loop (for, say, an Arduino `loop()` function) and includes basic setup. Also generate a `platformio.ini` with a default environment (like Arduino Uno) so the project is immediately buildable in PlatformIO. *End* when the API can produce a set of text blobs for each file that together form a self-contained PlatformIO project. Check that the code compiles (manually, outside the app) or at least that it looks syntactically correct for C.

* **Package Zip Archive:** *Start* by using a Node library (e.g. `adm-zip`) to programmatically add the generated files to a ZIP archive. Include all source files and config files in a proper folder structure (e.g., `/src` directory for source code, plus the `platformio.ini`). *End* when the API, given a model, responds with a binary ZIP file download. Test by hitting the endpoint for a simple model and then opening the ZIP to verify the files (e.g., ensure `model.c`, `model.h`, `main.c`, `platformio.ini` are present and contain the expected content).

* **Download Code from UI:** *Start* by integrating the frontend with the codegen API. Add a “Generate C Code” button in the editor page that, when clicked, calls the `/api/generate-code` route (sending the current model JSON). On response, trigger a download of the returned ZIP (setting the correct content-disposition or using Blob URLs in the browser). *End* when a user can click the button and the browser downloads a `model.zip` (or similar) file. Test by creating a small model, clicking “Generate C Code”, and then opening the ZIP to confirm it contains the code corresponding to the model.

## Final Testing & Verification

* **End-to-End Model Test:** *Start* by constructing a simple end-to-end scenario to verify all pieces together. For example, create a model with an Input feeding a Transfer Function and then to an Output, plus a Display and Logger. *End* when you can: log in, build this model on the canvas, run the simulation to see the Display updating and Logger collecting data, save the model to Supabase, reload it from the database to confirm persistence, and successfully generate a ZIP of C code for it. This final step is complete when each feature works in sequence and the overall user journey (design → simulate → save → load → codegen) is verified.
